#include <iostream>

#include "header.h"

using namespace std;

//Функция вывода на экран списка
void list::display()
{
	if (next != NULL) //Проверка на существование списка
	{
		item *temp = next; //Объявление и инициализация первым элементом временного указателя
		
		while (temp->next != NULL) //Проверка на существование следующего элемента
		{
			cout << temp->info << ", "; //Вывод на экран информации, которая хранится в элементе
			temp = temp->next; //Присвоение указателю адрес следующего элемента
		} 
		cout << temp->info << '.'; //Вывод на экран информации, которая хранится в последнем элементе
	}
	else cout << "Список пуст.";
}

void list::oper(int key_1, int key_2)
{
	item *A = first_item;
	item *B = first_item->next;

	for (int i = 1; A->next != NULL; i++)
	{
		if (key_1 == i) break;
		else A = A->next;
	}

	for (int i = 2; B->next != NULL; i++)
	{
		if (key_2 == i) break;
		else B = B->next;
	}

	item *C = *A + *B;
	this->add(C->info);
}

item* operator+(item A, item B)
{
	item *C = new item;
	C->info = A.info + B.info;
	return C;
}

//Функция добавления элемента в начало списка
void list::add(double data)
{
	item *temp = new item; //Выделение памяти новому элементу
	summ++; //Увеличение счётчика на один

	if (summ > 1) //Если элементов больше одного
	{
		first_item->previous = temp; //Указание первому элементу адрес нового, как предыдущего
		temp->next = first_item; //Указание новому элементу адрес первого, как следующего
	}
	else
	{
		temp->next = NULL; //Присвоение указателю нового элемента на следующий NULL
		last_item = temp; //Присвоение указателю на последний элемент адрес нового
	}

	this->next = temp; //Присвоение указателю объекта на следующий элемент адрес нового
	first_item = temp; //Присвоение указателю на первый элемент адрес нового

	temp->previous = this; //Указание первому элементу адрес объекта, как предыдущего
	temp->info = data; //Присвоение полю информации нового элемента полученных данных
}

//Функция замены данных
void list::change(int key)
{
	item *temp = first_item; //Объявление и инициализация адресом первого элемента временного указателя

	for (int i = 1; temp != NULL; i++) //Проход всего списка на поиск нужного элемента по номеру
	{
		if (i == key)
		{
			double data;
			cout << "\nВведите новое значение элемента: ";
			cin >> data;

			temp->info = data; //Присвоение новых данных
		}
		temp = temp->next; //Присвоение временному указателю адрес на следующий элемент
	}
}

//Функция поиска элемента
void list::search(double key)
{
	if (key && first_item) //Проверка на существование "ключа" и списка
	{
		item *temp = first_item; //Объявление и инициализация адресом первого элемента временного указателя
		int i = 0, j;

		cout << "Найдено (номера элементов в списке): ";
		for (j = 1; temp != NULL; j++) //Проход всего списка на поиск нужного элемента по "ключу"
		{			
			if (temp->info == key)
			{
				if (i > 0) cout << ", ";

				i++; //Счётчик найденного
				cout << j; //Вывод номера элемента на экран
			}
			temp = temp->next; //Присвоение временному указателю адрес на следующий элемент
		}

		if (i == 0) //Если счётчик равен нулю
		{
			cout << "ничего не найдено.\n";
			return;
		}

		//Вывод на экран нужного окончания в зависимости от числа
		cout << ".\nВсего " << i << " соответстви";
		if (i % 10 == 1 && i != 11)
		{
			cout << "е.\n";
		}
		else if ((i % 10 == 2 || i % 10 == 3 || i % 10 == 4) && (i != 12 || i != 13 || i != 14))
		{
			cout << "я.\n";
		}
		else
		{
			cout << "й.\n";
		}
	}
	else cout << "Отсутствует либо ключевое слово, либо список.\n";
}

//Функция сортировки списка (пузырёк)
void list::sort(double key)
{
	int summ_temp = summ, swap; //Объявление необходимых переменных
	item *A = NULL, *B = NULL; //Объявление и инициализация NULL-ом двух временных указателей
	
	if (summ <= 1) //Проверка на то, что список состоит из минимум двух элементов
	{
		cout << "Список отсортирован.\n";
		return;
	}

	//Сортировка
	do
	{	
		//Проверка на вид сортировки и задание начальных условий
		if (key == 1) //По возрастанию
		{
			A = this;
			B = this->next;
		}
		else if (key == 2) //По убыванию
		{
			A = NULL;
			B = last_item;
		}

		summ_temp--;
		swap = 0;
		for (int i = 0; i < summ_temp; i++)
		{
			//Проверка на вид сортировки и задание начальных условий прохода
			if (key == 1) //По возрастанию
			{
				A = B;
				B = B->next;
			}
			else if (key == 2) //По убыванию
			{
				A = B;
				B = B->previous;
			}
			
			if (A->info > B->info) //Замена данных, если необходимо
			{
				std::swap(A->info, B->info);
				swap++;
			}
		}
	} while (swap != 0);

	cout << "Список отсортирован.\n";
}